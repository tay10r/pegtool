#ifndef PEGTOOL_H
#define PEGTOOL_H

#include <iosfwd>
#include <memory>

#include <stddef.h>

namespace peg {

class GrammarImpl;
class Module;

/// @brief This class contains all the definitions of a grammar.
///
/// @detail When using this library, this class is the first to be logically
/// declared. When an instance of a grammar class is made, it is initially
/// empty. The caller is required to parse the grammar file to initialize it
/// with the appropriate grammar definitions. Once the grammar instance has
/// definitions in it, it can then be used to "compile" a parser into a
/// @ref Module object.
class Grammar final
{
public:
  Grammar() = default;

  Grammar(Grammar&&) noexcept;

  ~Grammar();

  /// Indicates if there are any diagnostics in the grammar. It does not mean
  /// the grammar is malformed if this function returns true, since diagnostics
  /// may only be warnings.
  bool hasDiagnostics() const noexcept;

  /// Indicates if the grammar has at least one diagnostic that is considered an
  /// error. If this function returns true, the grammar should no longer be
  /// processed.
  bool hasErrors() const noexcept;

  /// Prints the diagnostics in the grammar to a stream.
  void printDiagnostics(std::ostream&) const;

  /// @brief Parses a string containing a grammar specification.
  ///
  /// @detail Diagnostics may be generated after calling this function. It is a
  /// good idea to call @ref Grammar::hasErrors to figure out if the grammar is
  /// malformed or not. Calling @ref Grammar::hasDiagnostics can also indicate
  /// if there are any warnings (or errors) instead of just checking for errors.
  ///
  /// @param src
  /// A pointer to the string containing the grammar specification.
  ///
  /// @param len
  /// The number of bytes in the grammar specification, not including any null
  /// terminating character.
  ///
  /// @param name
  /// The name of the grammar. This is used when generating diagnostics and can
  /// either be the path of the grammar file or the name of the language that it
  /// is for.
  void parse(const char* src, size_t len, const char* name = nullptr);

  /// @brief Does the same as the other parse function, except that the length
  /// of the string is determined by finding the null terminator and the name of
  /// the grammar is not specified.
  void parse(const char* src);

private:
  friend Module; // For read-only access to implPtr

  GrammarImpl* implPtr = nullptr;

  GrammarImpl& getImpl();
};

class ModuleImpl;
class ParseTree;

/// @brief A module contains the byte code of the parser.
///
/// @detail Modules contain all the code and rule labels used by the parser VM.
/// They can either be used to run the parser directly or to convert the
/// bytecode to C++.
class Module final
{
public:
  /// Constructs an empty module.
  Module() = default;

  /// Moves a module from one variable to another.
  ///
  /// @note The previous module passed to this constructor
  /// should no longer be used.
  Module(Module&&) noexcept;

  /// Releases all memory allocated by the module.
  ~Module();

  /// @brief Prints the bytecode and labels to a stream.
  ///
  /// @detail This function is mostly used for internal debugging. Library users
  /// are unlikely to need this function, but it can help to get insight on how
  /// the generated parser works.
  ///
  /// @param stream The stream to print the module to.
  void print(std::ostream&) const;

  /// Compiles a grammar to bytecode and inserts it into the module.
  ///
  /// @param grammar The grammar to load into the module.
  ///
  /// @return True on success, false on failure.
  bool load(const Grammar& grammar);

  /// Runs the compiled grammar on a input string.
  ///
  /// @param input A pointer to the input string. Since the length is given in
  /// this function call, it does not need to be null-terminated.
  ///
  /// @param length The length of the input string, in terms of bytes.
  ///
  /// @return An instance of the parse tree generated by the parser.
  auto exec(const char* input, size_t length) -> ParseTree;

private:
  ModuleImpl* implPtr = nullptr;

  ModuleImpl& getImpl();
};

class Terminal;
class NonTerminal;

/// This can be used to access the derived symbols in the syntax tree.
class SymbolVisitor
{
public:
  virtual ~SymbolVisitor() = default;

  virtual void visit(const ParseTree&, const Terminal&) = 0;

  virtual void visit(const ParseTree&, const NonTerminal&) = 0;
};

class ParseTreeImpl;

/// Represents terminal symbols, which are symbols that appear on the right side
/// of the rule and do not appear on the left side. They consist of only
/// character content and have no child symbols.
class Terminal final
{
public:
  size_t getLength() const noexcept { return this->length; }

private:
  friend ParseTree;
  friend ParseTreeImpl;
  /// The offset of the terminal within the input string.
  size_t offset = 0;
  /// The number of bytes in the terminal.
  size_t length = 0;
};

class NonTerminal final
{
public:
  size_t getChildrenCount() const noexcept { return this->childrenCount; }

private:
  friend ParseTree;
  friend ParseTreeImpl;
  /// The address for the function of the non-terminal in the bytecode module.
  size_t address = 0;
  /// The offset of the children symbols within the symbol index table.
  size_t childrenOffset = 0;
  /// The number of children in the terminal.
  size_t childrenCount = 0;
};

/// @brief Contains all the symbols found by the module.
///
/// @detail Also responsible for storing all the memory contents of the tree.
/// For this reason, most calls to walk the tree will require interfacing to
/// this object.
///
/// @note The original source code string passed to @ref Module::exec should
/// have a longer lifetime than the concrete syntax tree. The CST references the
/// original source code string in all the terminal objects. So if the original
/// source code string were to be freed, then it would cause access violations
/// when walking the tree.
class ParseTree final
{
public:
  ParseTree() = default;

  ParseTree(ParseTree&&) noexcept;

  ~ParseTree();

  /// Gets the character data captured by a terminal.
  ///
  /// @return A pointer to the character data associated with the terminal.
  const char* getCharData(const Terminal&) const;

  /// Gets the name associated with a non-terminal.
  ///
  /// @return The name of the non-terminal. If, for some reason, the name of the
  /// non-terminal is not found, an empty return constant is returned instead.
  /// This does not have to be checked, because generally it can't happen. The
  /// only reason it would is if the non-terminal passed to this function is
  /// from a different parse tree instance.
  const char* getName(const NonTerminal&) const;

  /// Gets the result of the first rule in the grammar. If the root non-terminal
  /// contains no children, then the module failed to parse anything.
  ///
  /// @return A reference to the first rule in the grammar.
  const NonTerminal& getRoot() const noexcept;

  /// Recursively prints the non-terminal onto a stream.
  void print(const NonTerminal&, std::ostream&) const;

  /// Passes the derived children of a non-terminal to a symbol visitor.
  ///
  /// @note This is a non-recursive function, so the children's children are not
  /// visited unless it's done in a separate call.
  void visitChildren(const NonTerminal&, SymbolVisitor&) const;

private:
  friend Module;

  ParseTreeImpl* implPtr = nullptr;

  ParseTreeImpl& getImpl();
};

} // namespace peg

#endif // PEGTOOL_H
